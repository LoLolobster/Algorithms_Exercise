# 对象的内存大小

### 对象

一个对象占用的内存空间基本上有以下几部分：

* 对象本身的开销16字节；
* 对象的所有成员变量（引用类型为8字节）；
* 将大小填充为机器字（64bit）整倍数的额外字节；

![memory requirement of Integer](C:\Users\HP\Desktop\Algorithms笔记\mdPics\Integer-memory.png)

*Integer：对象开销（16）+ 成员变量（int：4）+ padding（4）*

![memory requirement of Integer](C:\Users\HP\Desktop\Algorithms笔记\mdPics\Date-memory.png)

*Date：对象开销（16）+ 成员变量（int：4x3）+padding（4）*

### 链表

嵌套的非静态（内部）类，例如链表的中的`Node`类，还需要：

* 额外的8字节保存一个指向外部类的引用；

![memory requirement of Integer](C:\Users\HP\Desktop\Algorithms笔记\mdPics\Node-memory.png)

*对象开销（16）+ 额外开销（8）+ 成员变量（8+8）*

对于一个保存了N个`Integer`的链表实现的栈，其大小为：

* `Stack`对象本身的16字节开销；
* 对成员变量`first`的引用占了8字节；
* 成员变量`N`的4字节；
* `N`个结点的大小：（`item`的24字节 + `next`的40字节）* N；
* 4个字节的padding；

### 数组

**原始数据类型的数组**

* 24字节的头信息（16字节的对象开销 + 4字节保存数组长度 + 4字节padding）；
* 保存值所需要的内存；

例如一个含有N个值的int型数组的大小为（24+4N）字节（未计入padding）；

**引用类型的数组**

* 在上述基础上还要为每个引用类型对象保存一个8字节的引用；

例如一个含有N个Date对象的数组需要（24 + 40N）个字节；

**二维数组**

二维数组是数组的数组，一个M*N的int型二维数组大小为：
24字节头信息 （数组的数组开销）+ 24M字节头信息（每个元素数组的头信息开销）+ 8M字节（对所有的一维数组的引用开销）+ 4MN保存所有元素的值的开销；

### 字符串对象

除字符数组之外，字符串对象的大小主要构成为：

* 字符串对象开销16字节；
* 成员变量（ int:4 * 3 ）；
* 数组引用8字节；
* 4字节的padding；

==因为`String`的`char`数组是多个字符串共享的，所以需要另计；==

这样的设计能使得多个对象含有相同的`value[]`数组时节省内存；

也就是说`String`从语言的角度上是一个引用类型，但是在内存实现上又和基本类型相似（对同一个内存地址的值通过多个引用进行共享）；

### 字符串的值和子字符串

前面我们说过，字符串的值（字符数组）在多个字符串之间是共享的，实际上，我们使用`subString`方法得到的子字符串的值也是通过和原字符串共享而来的；

==因此，创建一个子字符串，无论其大小如何，时间和内存开销都是一个常数==。



## 总结

这些基础机制已经足够分析大部分算法程序，但是仍然有很多复杂因素会导致部分程序的分析很困难；

比如在函数调用时，会开辟方法栈来保存局部变量，如果在递归函数中创建数组或者是其他大型对象，那么随着递归的深入方法栈也会越来越多（只有当返回时方法栈才会被交还给系统栈），这将消耗大量内存。