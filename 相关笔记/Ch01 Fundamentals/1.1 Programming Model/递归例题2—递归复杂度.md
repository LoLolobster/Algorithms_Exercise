# 递归例题2

> 原书1.1.20；
>
> 编写一个静态的递归方法计算$ln(N!)$的值。

**思路**

拿到手第一想法，for循环不就完了吗。诶不错，实际上通过1.1.19的两种斐波那契我们也能看出来，某些情况下for循环和递归调用是可以相互转换的（比如累加，累乘等等）。

**代码**

```java
public static double getValue(int N){
    if (N == 0 || N == 1) return 0.0; //0和1的阶乘都是1
    return Math.log(N) + getValue(N-1);
}
```

这个代码很简单，没有什么好解释的。

**但是**

本篇的重点来了：同样是for循环与递归的转换，为什么斐波那契的前后复杂度相差那么大而本题却几乎没有变化呢？

实际上原因也很简单：在斐波那契中，一个==**父递归函数在同一个分支中会多次调用递归子函数**==。也就是说，递归函数每往下走一层，时间复杂度都是==**指数级增长**==。而在本题中，父递归函数与子递归函数在各分支中最多也只是==**一对一**==的关系，因此时间==**复杂度就是个N**==。

这就给我们提醒：

**一 定 要 注 意 父 递 归 函 数 与 子 递 归 函 数 的 数 量 对 应 ！**

